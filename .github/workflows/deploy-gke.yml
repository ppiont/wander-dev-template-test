name: Deploy to GKE

on:
  push:
    branches:
      - master
      - main

permissions:
  contents: read
  id-token: write
  security-events: write
  actions: read

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GKE_CLUSTER: ${{ secrets.GKE_CLUSTER_NAME }}
  GKE_REGION: ${{ secrets.GKE_REGION }}
  ARTIFACT_REGISTRY: ${{ secrets.GKE_REGION }}-docker.pkg.dev
  REPOSITORY: ${{ secrets.GCP_PROJECT_ID }}/wander-app
  IMAGE_TAG: ${{ github.sha }}
  WORKLOAD_IDENTITY_PROVIDER: ${{ secrets.WIF_PROVIDER }}
  SERVICE_ACCOUNT: ${{ secrets.WIF_SERVICE_ACCOUNT }}

jobs:
  build-and-scan:
    name: Build and Scan Images
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955 # v4.3.0

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@c200f3691d83b41bf9bbd8638997a462592937ed # v2.1.13
        with:
          workload_identity_provider: ${{ env.WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ env.SERVICE_ACCOUNT }}

      - name: Configure gcloud & Docker
        run: |
          gcloud config set project ${{ env.PROJECT_ID }}
          gcloud auth configure-docker ${{ env.ARTIFACT_REGISTRY }} --quiet

      - name: Build and push Docker images
        run: |
          # Build and push API (SHA tag only)
          docker build -t ${{ env.ARTIFACT_REGISTRY }}/${{ env.REPOSITORY }}/api:${{ env.IMAGE_TAG }} \
            ./src/api
          docker push ${{ env.ARTIFACT_REGISTRY }}/${{ env.REPOSITORY }}/api:${{ env.IMAGE_TAG }}

          # Build and push Frontend (SHA tag only)
          docker build -t ${{ env.ARTIFACT_REGISTRY }}/${{ env.REPOSITORY }}/frontend:${{ env.IMAGE_TAG }} \
            ./src/frontend
          docker push ${{ env.ARTIFACT_REGISTRY }}/${{ env.REPOSITORY }}/frontend:${{ env.IMAGE_TAG }}

      - name: Run Trivy vulnerability scanner on API image
        uses: aquasecurity/trivy-action@b6643a29fecd7f34b3597bc6acb0a98b03d33ff8 # v0.33.1
        with:
          image-ref: ${{ env.ARTIFACT_REGISTRY }}/${{ env.REPOSITORY }}/api:${{ env.IMAGE_TAG }}
          format: 'sarif'
          output: 'trivy-api-results.sarif'
          severity: 'CRITICAL,HIGH'
        env:
          TRIVY_CACHE_KEY: trivy-api-${{ runner.os }}-${{ github.run_id }}

      - name: Run Trivy vulnerability scanner on Frontend image
        uses: aquasecurity/trivy-action@b6643a29fecd7f34b3597bc6acb0a98b03d33ff8 # v0.33.1
        with:
          image-ref: ${{ env.ARTIFACT_REGISTRY }}/${{ env.REPOSITORY }}/frontend:${{ env.IMAGE_TAG }}
          format: 'sarif'
          output: 'trivy-frontend-results.sarif'
          severity: 'CRITICAL,HIGH'
        env:
          TRIVY_CACHE_KEY: trivy-frontend-${{ runner.os }}-${{ github.run_id }}

      - name: Upload Trivy scan results for API to GitHub Security tab
        uses: github/codeql-action/upload-sarif@5d5cd550d3e189c569da8f16ea8de2d821c9bf7a # v3.31.2
        continue-on-error: true
        if: always()
        with:
          sarif_file: 'trivy-api-results.sarif'
          category: 'trivy-api'

      - name: Upload Trivy scan results for Frontend to GitHub Security tab
        uses: github/codeql-action/upload-sarif@5d5cd550d3e189c569da8f16ea8de2d821c9bf7a # v3.31.2
        continue-on-error: true
        if: always()
        with:
          sarif_file: 'trivy-frontend-results.sarif'
          category: 'trivy-frontend'

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: build-and-scan
    environment: staging

    steps:
      - name: Checkout
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955 # v4.3.0

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@c200f3691d83b41bf9bbd8638997a462592937ed # v2.1.13
        with:
          workload_identity_provider: ${{ env.WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ env.SERVICE_ACCOUNT }}

      - name: Configure gcloud
        run: |
          gcloud config set project ${{ env.PROJECT_ID }}
          gcloud components install gke-gcloud-auth-plugin --quiet

      - name: Get GKE credentials
        run: |
          gcloud container clusters get-credentials ${{ env.GKE_CLUSTER }} \
            --region=${{ env.GKE_REGION }}

      - name: Deploy to staging with Helm
        run: |
          helm upgrade --install wander-app ./helm/wander-app \
            --namespace staging \
            --create-namespace \
            --atomic \
            --timeout 5m \
            --values ./helm/wander-app/values-staging.yaml \
            --set api.image.repository=${{ env.ARTIFACT_REGISTRY }}/${{ env.REPOSITORY }}/api \
            --set api.image.tag=${{ env.IMAGE_TAG }} \
            --set frontend.image.repository=${{ env.ARTIFACT_REGISTRY }}/${{ env.REPOSITORY }}/frontend \
            --set frontend.image.tag=${{ env.IMAGE_TAG }} \
            --set postgres.auth.password=${{ secrets.DB_PASSWORD }}

      - name: Verify deployment
        run: |
          echo "=== Pods in staging namespace ==="
          kubectl get pods -n staging

          echo ""
          echo "=== Services in staging namespace ==="
          kubectl get services -n staging

          echo ""
          echo "=== Waiting for LoadBalancer IP ==="
          kubectl wait --for=jsonpath='{.status.loadBalancer.ingress}' \
            service/frontend \
            -n staging \
            --timeout=300s || true

          FRONTEND_IP=$(kubectl get service frontend -n staging -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          if [ -n "$FRONTEND_IP" ]; then
            echo ""
            echo "üéâ Staging deployment successful!"
            echo ""
            echo "Frontend URL: http://${FRONTEND_IP}:3000"
            echo "Environment: staging"
            echo ""
            echo "‚úÖ Test the staging deployment, then approve production deployment in GitHub Actions"
            echo ""
          else
            echo "‚ö†Ô∏è  LoadBalancer IP not yet assigned. Check with: kubectl get service frontend -n staging"
          fi

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: deploy-staging
    environment: production

    steps:
      - name: Checkout
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955 # v4.3.0

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@c200f3691d83b41bf9bbd8638997a462592937ed # v2.1.13
        with:
          workload_identity_provider: ${{ env.WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ env.SERVICE_ACCOUNT }}

      - name: Configure gcloud
        run: |
          gcloud config set project ${{ env.PROJECT_ID }}
          gcloud components install gke-gcloud-auth-plugin --quiet

      - name: Get GKE credentials
        run: |
          gcloud container clusters get-credentials ${{ env.GKE_CLUSTER }} \
            --region=${{ env.GKE_REGION }}

      - name: Deploy to production with Helm
        run: |
          helm upgrade --install wander-app ./helm/wander-app \
            --namespace production \
            --create-namespace \
            --atomic \
            --timeout 5m \
            --values ./helm/wander-app/values-production.yaml \
            --set api.image.repository=${{ env.ARTIFACT_REGISTRY }}/${{ env.REPOSITORY }}/api \
            --set api.image.tag=${{ env.IMAGE_TAG }} \
            --set frontend.image.repository=${{ env.ARTIFACT_REGISTRY }}/${{ env.REPOSITORY }}/frontend \
            --set frontend.image.tag=${{ env.IMAGE_TAG }} \
            --set postgres.auth.password=${{ secrets.DB_PASSWORD }}

      - name: Verify deployment
        id: get-url
        run: |
          echo "=== Pods in production namespace ==="
          kubectl get pods -n production

          echo ""
          echo "=== Services in production namespace ==="
          kubectl get services -n production

          echo ""
          echo "=== Waiting for LoadBalancer IP ==="
          kubectl wait --for=jsonpath='{.status.loadBalancer.ingress}' \
            service/frontend \
            -n production \
            --timeout=300s || true

          FRONTEND_IP=$(kubectl get service frontend -n production -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          echo "ip=$FRONTEND_IP" >> $GITHUB_OUTPUT

          if [ -n "$FRONTEND_IP" ]; then
            echo ""
            echo "üöÄ Production deployment successful!"
            echo ""
            echo "Frontend URL: http://${FRONTEND_IP}:3000"
            echo "Environment: production"
            echo ""
          else
            echo "‚ö†Ô∏è  LoadBalancer IP not yet assigned. Check with: kubectl get service frontend -n production"
          fi
