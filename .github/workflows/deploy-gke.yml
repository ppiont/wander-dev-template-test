name: Deploy to GKE

on:
  push:
    branches:
      - master
      - main

permissions:
  contents: read
  id-token: write
  security-events: write
  actions: read

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GKE_CLUSTER: ${{ secrets.GKE_CLUSTER_NAME }}
  GKE_REGION: ${{ secrets.GKE_REGION }}
  ARTIFACT_REGISTRY: ${{ secrets.GKE_REGION }}-docker.pkg.dev
  REPOSITORY: ${{ secrets.GCP_PROJECT_ID }}/wander-app
  IMAGE_TAG: ${{ github.sha }}
  WORKLOAD_IDENTITY_PROVIDER: ${{ secrets.WIF_PROVIDER }}
  SERVICE_ACCOUNT: ${{ secrets.WIF_SERVICE_ACCOUNT }}

jobs:
  build-and-scan:
    name: Build and Scan Images
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955 # v4.3.0

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@c200f3691d83b41bf9bbd8638997a462592937ed # v2.1.13
        with:
          workload_identity_provider: ${{ env.WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ env.SERVICE_ACCOUNT }}

      - name: Set up gcloud CLI
        uses: google-github-actions/setup-gcloud@5a5f7b85fca43e76e53463acaa9d408a03c98d3a # v2.1.0
        with:
          project_id: ${{ env.PROJECT_ID }}

      - name: Configure Docker for Artifact Registry
        run: |
          gcloud auth configure-docker ${{ env.ARTIFACT_REGISTRY }} --quiet

      - name: Build and push Docker images
        run: |
          # Build and push API (SHA tag only)
          docker build -t ${{ env.ARTIFACT_REGISTRY }}/${{ env.REPOSITORY }}/api:${{ env.IMAGE_TAG }} \
            ./src/api
          docker push ${{ env.ARTIFACT_REGISTRY }}/${{ env.REPOSITORY }}/api:${{ env.IMAGE_TAG }}

          # Build and push Frontend (SHA tag only)
          docker build -t ${{ env.ARTIFACT_REGISTRY }}/${{ env.REPOSITORY }}/frontend:${{ env.IMAGE_TAG }} \
            ./src/frontend
          docker push ${{ env.ARTIFACT_REGISTRY }}/${{ env.REPOSITORY }}/frontend:${{ env.IMAGE_TAG }}

      - name: Run Trivy vulnerability scanner on API image
        uses: aquasecurity/trivy-action@b6643a29fecd7f34b3597bc6acb0a98b03d33ff8 # v0.33.1
        with:
          image-ref: ${{ env.ARTIFACT_REGISTRY }}/${{ env.REPOSITORY }}/api:${{ env.IMAGE_TAG }}
          format: 'sarif'
          output: 'trivy-api-results.sarif'
          severity: 'CRITICAL,HIGH'

      - name: Run Trivy vulnerability scanner on Frontend image
        uses: aquasecurity/trivy-action@b6643a29fecd7f34b3597bc6acb0a98b03d33ff8 # v0.33.1
        with:
          image-ref: ${{ env.ARTIFACT_REGISTRY }}/${{ env.REPOSITORY }}/frontend:${{ env.IMAGE_TAG }}
          format: 'sarif'
          output: 'trivy-frontend-results.sarif'
          severity: 'CRITICAL,HIGH'

      - name: Upload Trivy scan results for API to GitHub Security tab
        uses: github/codeql-action/upload-sarif@5d5cd550d3e189c569da8f16ea8de2d821c9bf7a # v3.31.2
        if: always()
        with:
          sarif_file: 'trivy-api-results.sarif'
          category: 'trivy-api'

      - name: Upload Trivy scan results for Frontend to GitHub Security tab
        uses: github/codeql-action/upload-sarif@5d5cd550d3e189c569da8f16ea8de2d821c9bf7a # v3.31.2
        if: always()
        with:
          sarif_file: 'trivy-frontend-results.sarif'
          category: 'trivy-frontend'

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: build-and-scan
    environment: staging

    steps:
      - name: Checkout
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955 # v4.3.0

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@c200f3691d83b41bf9bbd8638997a462592937ed # v2.1.13
        with:
          workload_identity_provider: ${{ env.WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ env.SERVICE_ACCOUNT }}

      - name: Set up gcloud CLI
        run: |
          gcloud config set project ${{ env.PROJECT_ID }}
          gcloud components install gke-gcloud-auth-plugin --quiet

      - name: Get GKE credentials
        run: |
          gcloud container clusters get-credentials ${{ env.GKE_CLUSTER }} \
            --region=${{ env.GKE_REGION }}

      - name: Create namespace if it doesn't exist
        run: |
          kubectl create namespace staging --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy with Helm
        uses: deliverybot/helm@1c1b8b6230001a6a3bdb3eee1e8e3f96cd14fca5 # v1
        with:
          release: ${{ secrets.PROJECT_NAME || 'wander-app' }}
          namespace: staging
          chart: ./helm/wander-app
          task: upgrade-install
          version: ${{ env.IMAGE_TAG }}
          values: |
            api:
              image:
                repository: ${{ env.ARTIFACT_REGISTRY }}/${{ env.REPOSITORY }}/api
                tag: ${{ env.IMAGE_TAG }}
            frontend:
              image:
                repository: ${{ env.ARTIFACT_REGISTRY }}/${{ env.REPOSITORY }}/frontend
                tag: ${{ env.IMAGE_TAG }}
            postgres:
              auth:
                password: ${{ secrets.DB_PASSWORD }}
          value-files: >-
            [
              "./helm/wander-app/values-staging.yaml"
            ]
          helm: helm3
          atomic: true

      - name: Verify deployment
        run: |
          echo "=== Pods in staging namespace ==="
          kubectl get pods -n staging

          echo ""
          echo "=== Services in staging namespace ==="
          kubectl get services -n staging

          echo ""
          echo "=== Waiting for LoadBalancer IP ==="
          kubectl wait --for=jsonpath='{.status.loadBalancer.ingress}' \
            service/frontend \
            -n staging \
            --timeout=300s || true

          FRONTEND_IP=$(kubectl get service frontend -n staging -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          if [ -n "$FRONTEND_IP" ]; then
            echo ""
            echo "üéâ Staging deployment successful!"
            echo ""
            echo "Frontend URL: http://${FRONTEND_IP}:3000"
            echo "Environment: staging"
            echo ""
            echo "‚úÖ Test the staging deployment, then approve production deployment in GitHub Actions"
            echo ""
          else
            echo "‚ö†Ô∏è  LoadBalancer IP not yet assigned. Check with: kubectl get service frontend -n staging"
          fi

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: deploy-staging
    environment: production

    steps:
      - name: Checkout
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955 # v4.3.0

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@c200f3691d83b41bf9bbd8638997a462592937ed # v2.1.13
        with:
          workload_identity_provider: ${{ env.WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ env.SERVICE_ACCOUNT }}

      - name: Set up gcloud CLI
        run: |
          gcloud config set project ${{ env.PROJECT_ID }}
          gcloud components install gke-gcloud-auth-plugin --quiet

      - name: Get GKE credentials
        run: |
          gcloud container clusters get-credentials ${{ env.GKE_CLUSTER }} \
            --region=${{ env.GKE_REGION }}

      - name: Create namespace if it doesn't exist
        run: |
          kubectl create namespace production --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy with Helm
        uses: deliverybot/helm@1c1b8b6230001a6a3bdb3eee1e8e3f96cd14fca5 # v1
        with:
          release: ${{ secrets.PROJECT_NAME || 'wander-app' }}
          namespace: production
          chart: ./helm/wander-app
          task: upgrade-install
          version: ${{ env.IMAGE_TAG }}
          values: |
            api:
              image:
                repository: ${{ env.ARTIFACT_REGISTRY }}/${{ env.REPOSITORY }}/api
                tag: ${{ env.IMAGE_TAG }}
            frontend:
              image:
                repository: ${{ env.ARTIFACT_REGISTRY }}/${{ env.REPOSITORY }}/frontend
                tag: ${{ env.IMAGE_TAG }}
            postgres:
              auth:
                password: ${{ secrets.DB_PASSWORD }}
          value-files: >-
            [
              "./helm/wander-app/values-production.yaml"
            ]
          helm: helm3
          atomic: true

      - name: Verify deployment
        id: get-url
        run: |
          echo "=== Pods in production namespace ==="
          kubectl get pods -n production

          echo ""
          echo "=== Services in production namespace ==="
          kubectl get services -n production

          echo ""
          echo "=== Waiting for LoadBalancer IP ==="
          kubectl wait --for=jsonpath='{.status.loadBalancer.ingress}' \
            service/frontend \
            -n production \
            --timeout=300s || true

          FRONTEND_IP=$(kubectl get service frontend -n production -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          echo "ip=$FRONTEND_IP" >> $GITHUB_OUTPUT

          if [ -n "$FRONTEND_IP" ]; then
            echo ""
            echo "üöÄ Production deployment successful!"
            echo ""
            echo "Frontend URL: http://${FRONTEND_IP}:3000"
            echo "Environment: production"
            echo ""
          else
            echo "‚ö†Ô∏è  LoadBalancer IP not yet assigned. Check with: kubectl get service frontend -n production"
          fi
